位运算一般有三种作用：

高效地进行某些运算，代替其它低效的方式。

表示集合（常用于 状压 DP）。

题目本来就要求进行位运算。
有关 2 的幂的应用
由于位运算针对的是变量的二进制位，因此可以推广出许多与 2 的整数次幂有关的应用。

将一个数乘（除） 2 的非负整数次幂：
int mulPowerOfTwo(int n, int m) {  // 计算 n*(2^m)
  return n << m;
}//左移m位乘2^m
int divPowerOfTwo(int n, int m) {  // 计算 n/(2^m)
  return n >> m;
}//右移m位除2^m
我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别，如： -1 / 2 的值为 0 ，而 -1 >> 1 的值为 -1 。
取绝对值
int Abs(int n) {
  return (n ^ (n >> 31)) - (n >> 31);
  /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1
    若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)
    需要计算 n 和 -1 的补码，然后进行异或运算，
    结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */
}
取两个数的最大/最小值
// 如果 a >= b, (a - b) >> 31 为 0，否则为 -1
int max(int a, int b) { return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31)); }
int min(int a, int b) { return (a & ((a - b) >> 31)) | (b & (~(a - b) >> 31)); }
操作一个数的二进制位：
获取一个数二进制的某一位：
// 获取 a 的第 b 位，最低位编号为 0，比如获取3的第1位
//3->11,3>>1 = 01,01&1=01&01=01=1->第一位；
int getBit(int a, int b) { return (a >> b) & 1; }
将一个数二进制的某一位设置为 0：
// 将 a 的第 b 位设置为 0 ，最低位编号为 0
int unsetBit(int a, int b) { return a & ~(1 << b); }
将一个数二进制的某一位设置为 1：
// 将 a 的第 b 位设置为 1 ，最低位编号为 0
int setBit(int a, int b) { return a | (1 << b); }
a = 9,b = 2
a = 1001, b = 2
1 << b = 100
a|(1<<b) 1101
将一个数二进制的某一位取反：
// 将 a 的第 b 位取反 ，最低位编号为 0
int flapBit(int a, int b) { return a ^ (1 << b); }
a:1111,b = 2
1 << b = 100
a^(1<<b) = 1111 ^ 0100 = 1011
