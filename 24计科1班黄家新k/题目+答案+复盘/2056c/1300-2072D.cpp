
//题目：选择子数组左循环移位，最小化逆序对数量，输出最优子数组边界。
/*
我的思路：
	遍历所有序对，找到最多逆序对的i
	然后把这个i换到一个特定的位置end，这个位置有说法的：
		就是，如果你无脑挪最后一个，万一增加逆序对了呢？
		比如 2 1 1 5 5 5，你无脑挪2到最后，就增加了 
	所以end这个位置的特点：end后一个位置大于l，或者是最后一个（没有大于l的，不就放最后了）
	所以说白了，这个end就是我们要找的r
	l前面说了就是最多逆序对的i 
	
	我的思路，先l->r,再调整 r 
	
正确答案：	
         ***	不能固定 l ！！！！ *** 
	正确思路是l也得遍历，每一次都遍历r，找到最优的r 
	方向差不多，但是还是缺了点东西，一种动态计算最优贡献的思路，说白了就是没贪心 
	假设数组为 [3, 1, 2]，固定 l=1， 
	当r=1：
		子数组：[3]
		移位后：[3]（与原数组相同）
		- X（移位前逆序对）：子数组内无右侧元素，X = 0  
		- Y（移位后逆序对）：子数组内无左侧元素，Y = 0  
		- 增益（X-Y）：0 - 0 = 0（逆序对数量不变） 
	当r=2：
		子数组：[3,1] 
		移位前：3 > 1，形成 1 个逆序对  
		- X = 1（移位前逆序对数量：1）  

		移位后：[1,3], 1 < 3，不形成逆序对  
		- Y = 0（移位后逆序对数量：0）  

		增益 = X - Y = 1 - 0 = 1（逆序对减少 1 个，优于前一种情况）
	当r=3：
		子数组: [3,1,2] 
	 	移位前：3 > 1 且 3 > 2，形成 2 个逆序对  
			- X = 2（移位前逆序对数量：2）  

		移位后：[1,2,3]   均不形成逆序对  
			- Y = 0（移位后逆序对数量：0）  

		增益 = X - Y = 2 - 0 = 2（逆序对减少 2 个，当前最优）
看到了吧，这就是动态计算贡献的，既不是你说的“找到a[r]>a[l]就立刻返回”，
								也不是所谓的“直接放到最后”
								而是更优的动态计算贡献值	
								
		然后，如果这里有大于l的，那么在最后l交换位置的时候，Y就会增加
		代表换位后的逆序对数量】
		所以换位后减去换位前，得到的就是贡献
		由此，遍历所有l和r，找到所有贡献，取最大即可	
*/
#include <iostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<string>
#include<unordered_map>
#include<map>
#define ll long long
#include<cmath>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--){
    	ll n;
    	cin>>n;
    	vector<ll> a(n+1);
    	for(int i=1;i<=n;i++){
    		cin>>a[i];
    	}
		ll l=1,r=1;
		ll ans=0;
		for(int i=1;i<=n;i++){
			ll x=0;
			ll y=0;
			
			for(int j=i+1;j<=n;j++){
				if(a[i]>a[j]) x++;
				if(a[i]<a[j]) y++;
				ll res=x-y;
				if(ans<res){
					ans=res;
					l=i;
					r=j;
				}
				
			}
		}

    	cout<<l<<" "<<r<<endl;
    	
	}

    return 0;
}





