// 题目：给定 x,m，求有多少 y 满足 y∈[1,m], x!=y 且 xy 是 x 或 y 的因子。
// 太令人绝望了
// 最纯粹的暴力是枚举 y，但是 y 范围太大，会超时。考虑如何缩小一下 y 的范围。
// 可以证明 y 的位数一定小于等于 x 的位数，我们分两种情况讨论一下： 
// 若 xy 为 x 的因数，那么 xy≤x，此时若 y 的位数大于 x，那么显然 xy 的位数一定与 y 的位数相等，这是因为 y 比 x 多出的若干位没有发生变化，所以 y 的位数一定不超过 x 的位数；
// 若 xy 为 y 的因数，由于 x!=0，所以 xy!=y，因此 xy≤? y/2 ?（因为 y/2 是除 y 以外 y 的最大的可能的因数），而 ? y/2 ? = y>>1
//也就是说，xy 的位数一定小于 y 的位数，由第一种情况可知，如果 y 的位数大于 x 的位数，那么 xy 的位数一定与 y 的位数相等，显然不可能是 y 的因数，所以 y 的位数一定不超过 x 的位数。
// 综上所述，y 的位数一定不超过 x 的位数。这样我们每次枚举位数小于等于 x 的数即可，一组数据时间复杂度 O(n)，可以通过此题。

#include <bits/stdc++.h>
using namespace std;
#define ll long long

signed main()
{
    // 优化输入输出流，提高效率
    ios::sync_with_stdio(0);
    cout.tie(0);
    cin.tie(0);

    int T;
    // 读取测试用例的数量
    cin >> T;
    while(T--) {
        // 用于记录满足条件的 y 的数量
        ll ans = 0;
        ll x, m;
        // 读取 x 和 m 的值
        cin >> x >> m;
        // 枚举缩小后的范围内的 y
        // (1ll << ((int)__lg(x) + 1) 计算出不超过 x 二进制位数的最大数
        // min((1ll << ((int)__lg(x) + 1)), m + 1) 取不超过 x 二进制位数的最大数和 m + 1 中的较小值
        for(int i = 1; i < min((1ll << ((int)__lg(x) + 1)), m + 1); i++) {
            // 检查 i 是否不等于 x，并且 x 异或 i 的结果是 x 或 i 的约数
            if(i != x && (x % (i ^ x) == 0 || i % (i ^ x) == 0)) {
                // 满足条件，计数器加 1
                ans++;
            }
        }
        // 输出满足条件的 y 的数量
        cout << ans << '\n';
    }

    return 0;
}    
