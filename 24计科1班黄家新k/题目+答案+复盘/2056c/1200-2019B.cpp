//题目：n个点，每点和后面的所有点相连，成为一条线段，求被k条线段覆盖的点有多少 

/*
	就是找规律，对画好图后的每一个点进行找规律
	看当前i和对应的k有什么关联 
结论为： 
// 我们考虑分别计算每个点被多少条线段覆盖，
// 再用 map 统计被 k 条线段覆盖的点的个数即可。
// 对于编号为 i 的点：
// 当其为线段左端点时，可以连出 (n - i) 条线段，
// 因为它后面有 (n - i) 个点。

// 当其为线段右端点时，可以连出 (i - 1) 条线段，
// 因为它前面有 (i - 1) 个点。

// 当其在线段中时，可以被 (i - 1)×(n - i) 条线段覆盖，
// 因为它前面的 (i - 1) 个点可以向后面的 (n - i) 个点连线。

// 所以对于编号为 i 的点，
// 共可以被 (n - i) + (i - 1) + (i - 1)×(n - i) 条线段覆盖。
	
	
*/ 
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll T, n, q, k;
ll x[100005];
map<ll, ll> m;
int main()
{
    ios::sync_with_stdio(0);
    cout.tie(0);
    cin.tie(0);
  	cin >> T;
	while(T--) {
		m.clear();
		cin >> n >> q;
		for(int i=1; i<=n; i++) cin >> x[i];
		for(int i=1; i<=n; i++) {
			m[(n-i)+(i-1)+(i-1)*(n-i)]++; //统计点i答案   这是【正常情况】 
			if(i+1<=n) m[i*(n-i)]+=(x[i+1]-x[i]-1); //统计i与i+1之间答案 
			//这里就算连续，也不会影响，他只是计算不连续的点，比如1 6，那么中间的
			//2 3 4 5就都会单独拿出来算一遍他们被覆盖的段在哪，所以是【另类情况】 
		}
		for(int i=1; i<=q; i++) {
			cin >> k;
			cout << m[k] << " ";
		}
		cout << "\n";
	}

    return 0;
}
